<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单例模式如何在多线程下保证单例</title>
    <url>/2021/10/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BF%9D%E8%AF%81%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>实现方式：</strong></p>
<p><strong>1、 使用饿汉模式加载或使用static代码块</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingletonHungry &#123;</span><br><span class="line">    // 使用饿汉模式加载</span><br><span class="line">    private static SingletonHungry instance = new SingletonHungry();</span><br><span class="line">//    private static SingletonHungry instance;</span><br><span class="line">//    static &#123;</span><br><span class="line">//        instance = new SingletonHungry();</span><br><span class="line">//        System.out.println(&quot;使用static代码块实现单例，SingletonHungry.hashCode=&quot; + instance.hashCode());</span><br><span class="line">//    &#125;</span><br><span class="line">    private SingletonHungry() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonHungry getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;使用饿汉模式加载实现单例，SingletonHungry.hashCode=&quot; + instance.hashCode());</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; System.out.println(&quot;SingletonHungry.hashCode=&quot; + SingletonHungry.getInstance().hashCode() + &quot;，currentTime=&quot; + System.currentTimeMillis())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TItzmJKeyib6H8JpVnELNzEGE4htVZnr32NBNN23Yb1en31urNpgE2ZlgQic8rJ2guCOq6zUjAwkSC1Duxw2LRDw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TItzmJKeyib6H8JpVnELNzEGE4htVZnr3y66s00uu0wFxeBuUt5ThtZCeMOcAmBbZab2l4PK9SiaaPfRJGZAawzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>2、 使用DCL双检查锁机制</strong></p>
<p>(A).使用synchronized加锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingletonByDCLSync &#123;</span><br><span class="line">    private static SingletonByDCLSync instance = null;</span><br><span class="line">    </span><br><span class="line">    private SingletonByDCLSync() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public static SingletonByDCLSync getInstance() &#123;</span><br><span class="line">//        try &#123;</span><br><span class="line">//            if (null == instance) &#123;</span><br><span class="line">//                synchronized (SingletonByDCLSync.class) &#123;</span><br><span class="line">//                    // 为了与ReentrantReadWriteLock效率做对比</span><br><span class="line">//                    Thread.sleep(2000);</span><br><span class="line">//                    if (null == instance) &#123;</span><br><span class="line">//                        instance = new SingletonByDCLSync();</span><br><span class="line">//                    &#125;</span><br><span class="line">//                &#125;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//        &#125;</span><br><span class="line">        syncInit();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 同步的静态方法与类锁效果一样</span><br><span class="line">    synchronized private static void syncInit() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (null == instance) &#123;</span><br><span class="line">                instance = new SingletonByDCLSync();</span><br><span class="line">            &#125;</span><br><span class="line">            // 为了与ReentrantReadWriteLock效率做对比</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;使用DCL双检查锁机制（synchronized）实现单例&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; System.out.println(&quot;SingletonByDCLSync.hashCode=&quot; + SingletonByDCLSync.getInstance().hashCode() + &quot;，currentTime=&quot; + System.currentTimeMillis())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TItzmJKeyib6H8JpVnELNzEGE4htVZnr32o156QVVbqI4oDIJ6j8Ub1Cjm2xicehGCUaJfeFWSliaricQpiaG5YM28A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>(B).使用ReentrantReadWriteLock加锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SingletonByDCLLock &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonByDCLLock instance = null;</span><br><span class="line">    private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line">    private SingletonByDCLLock() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonByDCLLock getInstance() &#123;</span><br><span class="line">        if (null == instance) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 使用读锁共享原理提高效率</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                if (null == instance) &#123;</span><br><span class="line">                    instance = new SingletonByDCLLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;使用DCL双检查锁机制（ReentrantReadWriteLock）实现单例&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; System.out.println(&quot;SingletonByDCLLock.hashCode=&quot; + SingletonByDCLLock.getInstance().hashCode() + &quot;，currentTime=&quot; + System.currentTimeMillis())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TItzmJKeyib6H8JpVnELNzEGE4htVZnr3Mh1KdibNkAXBRy9xCmuB16DZB1YzujdAUtQHTe6jyr4Qozmld6CTWGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从运行结果证明了ReentrantReadWriteLock读锁共享原理，大家也可以尝试一下写锁、 “读写锁”、“写读锁”的效果，这些的效果跟synchronized是一样的，因为它们都是互斥（同步）。</p>
<p> <strong>3、 使用静态内置类（推荐）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class SingletonByInner implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2766178451076677731L;</span><br><span class="line">    private static class Singleton &#123;</span><br><span class="line">        private static final SingletonByInner instance = new SingletonByInner();</span><br><span class="line">    &#125;</span><br><span class="line">    private SingletonByInner() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonByInner getInstance() &#123;</span><br><span class="line">        return Singleton.instance;</span><br><span class="line">    &#125;</span><br><span class="line">//    protected Object readResolve() &#123;</span><br><span class="line">//        System.out.println(&quot;调用了readResolve()方法&quot;);</span><br><span class="line">//        return Singleton.instance;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                // 序列化</span><br><span class="line">                SingletonByInner inner = SingletonByInner.getInstance();</span><br><span class="line">                try &#123;</span><br><span class="line">                    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;C:\\temp\\serializable.txt&quot;)));</span><br><span class="line">                    oos.writeObject(inner);</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                // 反序列化</span><br><span class="line">                try &#123;</span><br><span class="line">                    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;C:\\temp\\serializable.txt&quot;)));</span><br><span class="line">                    SingletonByInner instance = (SingletonByInner) ois.readObject();</span><br><span class="line">                    ois.close();</span><br><span class="line">                    System.out.println(&quot;SingletonByInner.hashCode=&quot; + instance.hashCode() + &quot;，currentTime=&quot; + System.currentTimeMillis());</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不调用readResolve()方法的情况下，运行结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TItzmJKeyib6H8JpVnELNzEGE4htVZnr3ztv8Eu2eof6edX9lt03wrRk3kx6CX3NdXoygDPJY18QFhl6diapDibYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将注释代码解开，调用readResolve()方法，运行结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TItzmJKeyib6H8JpVnELNzEGE4htVZnr3jz7dvLiczFjwqCq51wYu9iccovRTMicbOloNdMJybUMc1friciaFxGGYiczQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>注：之所以要调用readResolve()方法，是因为此类实现了序列化接口，进行了序列化操作，破坏了单例模式。其它实现方式如果进行了序列化操作，同样需要调用readResolve()方法。</p>
<p><strong>4、 使用enum枚举数据类型（枚举enum和静态代码块的特性相似，构造方法会自动被调用）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class SingletonByEnum &#123;</span><br><span class="line">    public enum SingleEnum &#123;</span><br><span class="line">        obj;</span><br><span class="line">        private Object object;</span><br><span class="line">        SingleEnum() &#123;</span><br><span class="line">            object = new Object();</span><br><span class="line">        &#125;</span><br><span class="line">        public Object getObj() &#123;</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingletonByEnum() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getInstance() &#123;</span><br><span class="line">        return SingleEnum.obj.getObj();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;使用enum枚举数据类型实现单例&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; System.out.println(&quot;SingletonByEnum.hashCode=&quot; + SingletonByEnum.getInstance().hashCode() + &quot;，currentTime=&quot; + System.currentTimeMillis())).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/TItzmJKeyib6H8JpVnELNzEGE4htVZnr35zlW6eq3vY8tl58J8aasfYkuI3MucwAP9ick0ETADFzibZLSwvibLdjUg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
]]></content>
      <categories>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
